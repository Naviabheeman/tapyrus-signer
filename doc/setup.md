# How to set up new Tapyrus Signer Network

This document describes how to set up new Tapyrus Signer Network.

We can set up Tapyrus Signer Network and Tapyrus Core Network with the 'trusted' way desribed in [How to start tapyrus in dev mode?](https://github.com/chaintope/tapyrus-core/blob/master/doc/tapyrus/getting_started.md#how-to-start-tapyrus-in-dev-mode). The trusted setup requires to share each signer's private key with all signers. But each tapyrus signer should be treated as 'trustless' as wel as other blockchain system.

The following shows the protocol for setting up signer in a 'trustless' network which has n-singers and threshold t which t is less than n.

We suppose (or recommend) that all signers can communicate with each other using the efficient and secure protocol providing PFS(perfect forward secrecy)[^1], such as SSL/TLS protocol or Noise Protocol[^2].

[^1]: For more information about PFS, see the section 'D.5.1.7 Cryptoperiod and protection lifetime' in the 'IEEE Standard Specifications for Public-Key Cryptography' [IEEE Standard Specifications for Public-Key Cryptography](https://perso.telecom-paristech.fr/guilley/recherche/cryptoprocesseurs/ieee/00891000.pdf)
[^2]: [The Noise Protocol Framework](http://www.noiseprotocol.org/noise.html)

To support for setting up the Tapyrus Signer Network, we provide a command-line utility `tapyrus-setup`

## Step 1. Choose Network ID

Choose Network ID, which is a 32-bit integer, and share among all signers.

## Step 2. Generate key pair

Signer generates static key pairs using `tapyrus-setup createkey`.

```
tapyrus-setup createkey

output <static_private_key> <static_public_key>
```

This generates the private/public key pair based on secp256k1 elliptic curve, where:

- `static_private_key` is a private key with an extend WIF format[^3].
- `static_public_key` is a public key corresponding to `static_private_key` with a hex format string.

[^3]: [BIP-178: Version Extended WIF](https://github.com/bitcoin/bips/blob/master/bip-0178.mediawiki)

Each signer shares their own public key `static_public_key` to other signers.
And then, they sort received public keys.

In the following steps, Signers are supposed to be sorted by public keys and indexed as Signer[i] (i = 1, 2, 3, ..., n)

## Step 3. Generate static verifiable secret shares.

Signer[i] generates "static" VSS(verifiable secret share)[^4] with `tapyrus-setup createvss`.

```
tapyrus-setup createvss -public_key=1:<static_public_key[1]> -public_key=2:<static_public_key[2]> ... -public_key=n:<static_public_key[n]> -private_key=<static_private_key[i]> -nonce=<networkid>

output:
    <static_public_key[1]>: <static_vss[i, 1]>,
    <static_public_key[2]>: <static_vss[i, 2]>,
    ...
    <static_public_key[n]>: <static_vss[i, n]]>,
```

where:

- `static_public_key[]` is a sorted array of public keys of signers and input args `j:static_public_key[j]` (j = 1, 2, ..., n) is a index and public key generated by Signer[j] in Step 2.
- `private_key[i]` is a private key of Signer[i] generated in Step 2.
- `networkid` is Network ID we choose in Step 1. we use it as a nonce of encryption.

And then, Signer[i] send the generated `static_vss[i, j]` (j = 1, 2, ..., n; i != j) to the Signer[j].

`static_vss[i, j]` contains the following information:

- the public key `static_public_key[i]` which indicates the signer who sends this vss.
- the public key `static_public_key[j]` which indicates the signer to be received the `static_vss[i, j]`
- "positive" public commitments `commitments[k]` (k = 1, 2, ..., t)
- "positive" secret `secret[j]` to perform secret sharing scheme.
- "negative" public commitments `commitments[k]` (k = 1, 2, ..., t)
- "negative" secret `secret[j]` to perform secret sharing scheme.

`static_vss[i, j]` have 2 kinds of VSS, named "positive" and "negative". Only "positive" VSS is used to generate aggregated value. For more information, see [^6].
`static_vss[i, j]` also is encrypted using symmetric key encryption scheme ChaCha20-Poly1305 [^5] and encoding with Base58.
So in generally, one who doesn't know `static_private_key[i]` can not know the secret value `secret[j]` even if they get `static_vss[i, j]`.
But from a security point of view, Signer[i] should send the value to others using a secure communication channel with PFS.

For more information about encrypting and encoding `static_vss[i, j]`, see Appendix A.

[^4]: [Provably Secure Distributed Schnorr Signatures and a (t,n) Threshold Scheme for Implicit Cerfiticates](https://t.co/jMhQnovLcb)
[^5]: [ChaCha20 and Poly1305 for IETF Protocols](https://tools.ietf.org/html/rfc8439)

## Step 4. Generate an aggregated public key

Signer[i] receives secret value `static_vss[j, i]` (j = 1, 2, ..., n) from other Signer[j].
After receiving from all signers, Signer[i] aggregate public keys and compute their own secret `node_secret[i]`

```
tapyrus-setup aggregate -vss=1:<static_vss[1, i]> -vss=2:<static_vss[2, i]> ... -vss=n:<static_vss[n, i]> -private_key=<static_private_key[i]>

output: <aggregated_public_key> <node_secret[i]>
```

- `static_vss[j, i]`(j = 1, 2, ..., n: i != j) are secret values produced in Step 3 and sent from other Signer[j].
- `static_vss[i, i]` is produced by Signer[i] themselves in Step 3.
- `static_private_key[i]` is the static private key of Signer[i], generated in Step 2.

- `aggregated_public_key` is an aggregated public key.
- `node_secret[i]` is the secret key share of Signer[i].

Note that `node_secret[i]` is not encrpyted because it is not intended to send to any other signers. It should be kept secret from others.

## Step 5. Generate a genesis block

Whoever knows `aggregated_public_key` can generate a genesis block using tapyrus genesis utility `tapyrus-genesis`.
And then they share the block with all signers;

```
tapyrus-genesis -signblockpubkey=<aggregated_public_key>

output <block>
```

- `aggregated_public_key` is generated at Step 4.

This utility generates a block without block proof, so we must sign the block in the following steps.

We can use some command-line option. See also
[How to create a genesis block?](https://github.com/chaintope/tapyrus-core/blob/master/doc/tapyrus/getting_started.md#how-to-create-a-genesis-block)

## Step 6. Generate ephemeral key to sign the genesis block.

Signer[i] generates ephemeral key pairs using `tapyrus-setup createkey`.

```
tapyrus-setup createkey

output <ephemeral_private_key[i]> <ephemeral_public_key[i]>
```

## Step 7. Generate block vss.

As in Step 3, Signer[i] creates "ephemeral" VSS(verifiable secret share).

```

tapyrus-setup createvss -public_key=1:<ephemeral_public_key[1]> -public_key=2:<ephemeral_public_key[2]> ... -public_key=n:<ephemeral_public_key[n]> -private_key=<ephemeral_private_key[i]>

output: {
    <ephemeral_public_key[1]>: <ephemeral_vss[i, 1]>,
    <ephemeral_public_key[2]>: <ephemeral_vss[i, 2]>,
    ...
    <ephemeral_public_key[n]>: <ephemeral_vss[i, n]>,
}

```

Signer[i] does not have to specify a nonce used in the encryption. Nonce is optional in this step.

`ephemeral_vss[i, j]` contains the following information:

- the public key `ephemeral_public_key[i]` which indicates the signer who sends this vss.
- the public key `ephemeral_public_key[j]` which indicates the signer to be received the `ephemeral_vss[i, j]`
- "positive"[^6] public commitments `commitments[k]` (k = 1, 2, ..., t)
- "positive" secret `secret[j]` to perform secret sharing scheme.
- "negative" public commitments `commitments[k]` (k = 1, 2, ..., t)
- "negative" secret `secret[j]` to perform secret sharing scheme.

`ephemeral_public_key[i, j]` is encrypted in the same way as `static_vss` described in Step 3.

Signer[i] sends the generated values `ephemeral_vss[i, j]` to other signers.

[^6]: In schnorr signature schema used in Tapyrus Core, we use the random value "r" and the ephemeral point "R" on the elliptic curve, where R = rG (G is the generator of the curve). In Tapyrus signature schema we should choose R so that jacobi(y(R)) = 1 (if not, use (n - r) instead of r and generate R so that R = (n - r)G, where n is the order of the curve). So in this step, we should generate both "positive" secret and commitments that corresponds to r, and "negative" ones that corrensponds to (n - r). For more information, see [Tapyrus Schnorr Signature Specification](https://github.com/chaintope/tapyrus-core/blob/master/doc/tapyrus/schnorr_signature.md)

## Step 8. Sign the genesis block locally.

Signer[i] secretly receives `ephemeral_vss[j, i]` generated by other signers. Then Signer[i] generates `local_sig` using `tapyrus-setup sign`.
To generate `local_sig`, Signer[i] need at least t valid `ephemeral_vss[j, i]`s. In the following steps, we suppose that Signer[1], Signer[2], ... Signer[t] are honest signers providing a valid vss and Signer[i] got `ephemeral_vss[j, i]`(j = 1, 2, 3, ..., t).

```
tapyrus-setup sign -static_vss=1:<static_vss[1, i]> -static_vss=2:<static_vss[2, i]> ... -static_vss=t:<static_vss[t, i]> -ephemeral_vss=1:<ephemeral_vss[1, i]> -ephemeral_vss=2:<ephemeral_vss[2, i]> ... -ephemeral_vss=t:<ephemeral_vss[t, i]>   -aggregated_public_key=<aggregated_public_key> -nodesecret=<node_secret[i]> -private_key=<static_private_key[i]> -block=<block>

output: <local_sig[i]>
```

- `static_vss[j, i]` (j = 1, 2, ..., t) are the static VSSs generated by Step 3.
- `ephemeral_vss[j, i]` (j = 1, 2, ..., t) are the ephemeral VSSs generated by Step 7.
- `static_private_key[i]` is the static private key of Signer[i], generated in Step 2.
- `aggregated_public_key` is an aggregated public key, generated in Step 4.
- `node_secret[i]` is the secret key share of Signer[i], generated in Step 4.
- `block` is the genesis block without block proof.
- `local_sig[i]` is the "local signature" described as Î³i in the paper [^4]. signer[i] may reveal `local_sig[i]`.

Then each signer broadcasts their local_sig.

## Step 9. Compute the signature of the genesis block.

After collecting `local_sig`, we can compute the signature of the genesis block using `tapyrus-setup combinesig`

```
tapyrus-setup combinesig -sig=<local_sig[1]> -sig=<local_sig[2]> ... -sig=<local_sig[t]> -block=<block>

output: <block_with_signature>
```

- `local_sig[i]` is the local signatures broadcasted by signers.
- `block_with_signature` is the whole genesis block data with block proof as hex string format.

To make block proof, t `local_sig`s are required.
`local_sig`s generated by signers are public values, so signers can reveal them as plaintext without any encryption.

## Step 10. genesis.`networkid`

Create file named 'genesis.`networkid`' and fill it with `block_with_signature`.

## Next Step

Now we are ready to start tapyrus core and tapyrus signer network.

To start tapyrus core network, see [Start Tapyrus-core nodes](https://github.com/chaintope/tapyrus-core/blob/master/doc/tapyrus/getting_started.md#5-start-tapyrus-core-nodes).

To start tapyrus signer network, go to [How To configure Tapyrus Signer Network](./configuration.md). The secret values or keys refered in this document will be required to start Tapyrus Signer Network.

- `static_private_key[i]` and `static_public_key[i]` in Step 1
- `aggregated_public_key` and `node_secret[i]` in Step 3

In above list, `static_private_key` and `node_secret` must be treated as secret.

## Appendix A: Encoding and Encrypting the VSS

In this section, we describe the protocol to encode/encrypt the VSS.
`static_vss[i, j]` in Step 3 and `ephemeral_vss[i, j]` in Step 7 have same structure.

Below in this section, notation `vss` means `static_vss[i, j]` or `ephemeral_vss[i, j]`.

### Structure of static vss

As in Step 2 and Stpe 6 `static_vss` and `ephemeral_vss` have 7 fields:

| name                 | size      | explaination                                                                                      |
| -------------------- | --------- | ------------------------------------------------------------------------------------------------- |
| sender_public_key    | 33        | indicates the signer who sends the vss                                                            |
| receiver_public_key  | 33        | indicates the signer to be received the vss                                                       |
| len                  | 2         | number of commitments                                                                             |
| positive commitments | 33 \* len | commitments for secret value for r . an array of the points on the elliptic curve secp256k1.      |
| positive secret      | 32        | secret value for r to perform secret sharing scheme                                               |
| negative commitments | 33 \* len | commitments for secret value for (n - r). an array of the points on the elliptic curve secp256k1. |
| negative secret      | 32        | secret value for (n - r) to perform secret sharing scheme                                         |

### Encryption of `static_vss`

`static_vss` is processed in the rule listed below:

1. Compute p = ECDH(`static_private_key`, `receiver_static_public_key`). where ECDH is a Elliptic-Curve Diffie-Hellman function. p represents a point on the secp256k1 and has 33-byte length.
2. Compute k = h(p). where h is SHA256 hash function. k is used as 32-bytes symmetric key of ChaCha20-Poly1305.
3. Concat all fields except `sender_static_public_key`.
   payload = `receiver_static_public_key` || `len` || `positive commitments` || `positive secret` || `negative commitments` || `negative secret`
4. Let n be 64 bits of leading zeros followed by a 32-bit `networkid`(0x0000000000000000 || `networkid`).
5. Encrypt payload with ChaCha20-Poly1305 encrpytion function.
   enc_payload = chacha20_poly1305_encrypt(k, n, ad = '', payload)
6. Encode `sender_static_public_key` || enc_payload using Base58.

### Encryption of `ephemeral_vss`

`ephemeral_vss` is processed in the rule listed below.
it is the same as the encryption of `static_vss` except nonce used by chacha20_poly1305_encrypt function.

1. Compute k = ECDH(`ephemeral_private_key`, `receiver_ephemeral_public_key`).
2. Compute sk = h(k). where h is SHA256 hash function.
3. Concat all fields except `sender_ephemeral_public_key`.
   payload = `receiver_ephemeral_public_key` || `len` || `positive commitments` || `positive secret` || `negative commitments` || `negative secret`
4. Let n be a 96-bit null-nonce (0x000000000000000000000000).
5. Encrypt payload with ChaCha20-Poly1305 encrpytion function.
   enc_payload = chacha20_poly1305_encrypt(k, n, ad = '', payload)
6. Encode `sender_ephemeral_public_key` || enc_payload using Base58.

## Appendix B: Example Scenario

// TODO: Write usage of tapyrus-vss.

## Appendix C: Security Consideration

// TODO:

### Nonce used by Encrypting with ChaCha20-Poly1305

### Communicating with a protocol with PFS
