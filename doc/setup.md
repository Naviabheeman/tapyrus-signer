# How to set up new Tapyrus Signer Network

This document describes how to set up new Tapyrus Signer Network.

## Overview

We can set up Tapyrus Signer Network and Tapyrus Core Network with the 'trusted' way described in [How to start tapyrus in dev mode?](https://github.com/chaintope/tapyrus-core/blob/master/doc/tapyrus/getting_started.md#how-to-start-tapyrus-in-dev-mode). The trusted setup requires to share each signer's private key with all signers. But each signer in Tapyrus Signer Network should be treated as 'trustless' as well as other blockchain system.

The following shows the protocol for setting up signer in a 'trustless' network which has n-singers and threshold t which t is less than n.

We suppose (or recommend) that all signers can communicate with each other using the efficient and secure protocol providing PFS(perfect forward secrecy)[^1], such as SSL/TLS protocol or Noise Protocol[^2].

[^1]: For more information about PFS, see the section 'D.5.1.7 Cryptoperiod and protection lifetime' in the 'IEEE Standard Specifications for Public-Key Cryptography' [IEEE Standard Specifications for Public-Key Cryptography](https://perso.telecom-paristech.fr/guilley/recherche/cryptoprocesseurs/ieee/00891000.pdf)
[^2]: [The Noise Protocol Framework](http://www.noiseprotocol.org/noise.html)

To support for setting up the Tapyrus Signer Network, we provide a command-line utility `tapyrus-setup`

## Step 1. Choose Network ID

Choose Network ID, which is a 32-bit integer, and share among all signers.

## Step 2. Generate key pair

Signer generates node key pairs using `tapyrus-setup createkey`.

```
tapyrus-setup createkey

output <node_private_key> <node_public_key>
```

This generates the private/public key pair based on secp256k1 elliptic curve, where:

- `node_private_key` is a private key with an extend WIF format[^3].
- `node_public_key` is a public key corresponding to `node_private_key` with a hex format string.

[^3]: [BIP-178: Version Extended WIF](https://github.com/bitcoin/bips/blob/master/bip-0178.mediawiki)

Each signer shares their own public key `node_public_key` to other signers.
And then, they sort received public keys.

In the following steps, Signers are supposed to be sorted by public keys and indexed as Signer[i] (i = 1, 2, 3, ..., n)

## Step 3. Generate node verifiable secret shares.

Signer[i] generates "node" VSS(verifiable secret share)[^4] with `tapyrus-setup createnodevss`.

```
tapyrus-setup createnodevss --public_key=<node_public_key[1]> --public_key=<node_public_key[2]> ... --public_key=<node_public_key[n]> --private_key=<node_private_key[i]> --networkid=<networkid> --block_height=<block_height> --threshold=<t>

output:
    <node_public_key[1]>: <node_vss[i, 1]>,
    <node_public_key[2]>: <node_vss[i, 2]>,
    ...
    <node_public_key[n]>: <node_vss[i, n]]>,
```

where:

- `node_public_key[]` is an array of public keys generated by Signer[j] in Step 2.
- `node_private_key[i]` is a private key of Signer[i] generated in Step 2.
- `networkid` is Network ID we choose in Step 1. we use it as a nonce of encryption.
- `block_height` is a 64-bits integer to be applied to this node vss. In initial setup, this should be 0. This option is optional, default is 0.
- `t` is the minimum number of signers required to sign block.

And then, Signer[i] send the generated `node_vss[i, j]` (j = 1, 2, ..., n; i != j) to the Signer[j].

`node_vss[i, j]` contains the following information:

- the public key `node_public_key[i]` which indicates the signer who sends this vss.
- the public key `node_public_key[j]` which indicates the signer to be received the `node_vss[i, j]`
- "positive" public commitments `commitments[k]` (k = 0, 1, ..., t - 1)
- "positive" secret `secret[j]` to perform secret sharing scheme.
- "negative" public commitments `commitments[k]` (k = 0, 1, ..., t - 1)
- "negative" secret `secret[j]` to perform secret sharing scheme.

`node_vss[i, j]` have 2 kinds of VSS, named "positive" and "negative". Only "positive" VSS is used to generate aggregated value. For more information, see [^6].
`node_vss[i, j]` also is encrypted using symmetric key encryption scheme ChaCha20-Poly1305 [^5] and encoding with Base58.
So in generally, one who doesn't know `node_private_key[i]` can not know the secret value `secret[j]` even if they get `node_vss[i, j]`.
But from a security point of view, Signer[i] should send the value to others using a secure communication channel with PFS.

For more information about encrypting and encoding `node_vss[i, j]`, see Appendix A.

[^4]: [Provably Secure Distributed Schnorr Signatures and a (t,n) Threshold Scheme for Implicit Cerfiticates](https://t.co/jMhQnovLcb)
[^5]: [ChaCha20 and Poly1305 for IETF Protocols](https://tools.ietf.org/html/rfc8439)

## Step 4. Generate an aggregated public key

Signer[i] receives secret value `node_vss[j, i]` (j = 1, 2, ..., n) from other Signer[j].
After receiving from all signers, Signer[i] aggregate public keys and compute their own secret `node_secret_share[i]`

```
tapyrus-setup aggregate --vss=<node_vss[1, i]> --vss=<node_vss[2, i]> ... --vss=<node_vss[n, i]> --private_key=<node_private_key[i]>

output: <aggregated_public_key> <node_secret_share[i]>
```

- `node_vss[j, i]`(j = 1, 2, ..., n: i != j) are secret values produced in Step 3 and sent from other Signer[j].
- `node_vss[i, i]` is produced by Signer[i] themselves in Step 3.
- `node_private_key[i]` is the private key of Signer[i], generated in Step 2.
- `aggregated_public_key` is an aggregated public key.
- `node_secret_share[i]` is the secret key share of Signer[i].

Note that `node_secret_share[i]` is not encrpyted because it is not intended to send to any other signers. It should be kept secret from others.

## Step 5. Generate a genesis block

Whoever knows `aggregated_public_key` can generate a genesis block using Tapyrus genesis utility `tapyrus-genesis`.
And then they share the block with all signers;

```
tapyrus-genesis -signblockpubkey=<aggregated_public_key>

output <block>
```

- `aggregated_public_key` is generated at Step 4.
- `block` is encoded as a hex string. For more information, see [here](https://github.com/chaintope/tapyrus-core/blob/master/doc/tapyrus/signedblocks.md#block-structure-expansion-for-signed-block)

This utility generates a block without block proof, so we must sign the block in the following steps.

We can use some command-line option. See also
[How to create a genesis block?](https://github.com/chaintope/tapyrus-core/blob/master/doc/tapyrus/getting_started.md#how-to-create-a-genesis-block)

## Step 6. Generate block key to sign the genesis block.

Signer[i] generates block key pairs using `tapyrus-setup createkey`.

```
tapyrus-setup createkey

output <block_private_key[i]> <block_public_key[i]>
```

## Step 7. Generate block vss.

As in Step 3, Signer[i] creates "block" VSS(verifiable secret share).

```

tapyrus-setup createblockvss --node_public_key=<node_public_key[1]> --node_public_key=<node_public_key[2]> ... --node_public_key=n:<node_public_key[n]> --block_private_key=<block_private_key[i]> --node_private_key=<block_private_key[i]> --threshold=<t>

output: {
    <node_public_key[1]>: <block_vss[i, 1]>,
    <node_public_key[2]>: <block_vss[i, 2]>,
    ...
    <node_public_key[n]>: <block_vss[i, n]>,
}

```

where:

- `node_public_key[]` is an array of public keys generated by Signer[j] in Step 2.
- `node_private_key[i]` is a private key of Signer[i] generated in Step 2.
- `block_private_key[i]` is a private key of Signer[i] generated in Step 6.
- `t` is the minimum number of signers required to sign block.

Signer[i] does not have to specify a nonce used in the encryption. Nonce is optional in this step.

`block_vss[i, j]` contains the following information:

- the public key `node_public_key[i]` which indicates the signer who sends this vss.
- the public key `node_public_key[j]` which indicates the signer to be received the `block_vss[i, j]`
- "positive"[^6] public commitments `commitments[k]` (k = 1, 2, ..., t)
- "positive" secret `secret[j]` to perform secret sharing scheme.
- "negative" public commitments `commitments[k]` (k = 1, 2, ..., t)
- "negative" secret `secret[j]` to perform secret sharing scheme.

`block_public_key[i, j]` is encrypted in the same way as `node_vss` described in Step 3.

Signer[i] sends the generated values `block_vss[i, j]` to other signers.

[^6]: In schnorr signature schema used in Tapyrus Core, we use the random value "r" and the ephemeral point "R" on the elliptic curve, where R = rG (G is the generator of the curve). In Tapyrus signature schema we should choose R so that jacobi(y(R)) = 1 (if not, use (n - r) instead of r and generate R so that R = (n - r)G, where n is the order of the curve). So in this step, we should generate both "positive" secret and commitments that corresponds to r, and "negative" ones that corrensponds to (n - r). For more information, see [Tapyrus Schnorr Signature Specification](https://github.com/chaintope/tapyrus-core/blob/master/doc/tapyrus/schnorr_signature.md)

## Step 8. Sign the genesis block locally.

Signer[i] secretly receives `block_vss[j, i]` generated by other signers. Then Signer[i] generates `local_sig` using `tapyrus-setup sign`.

```
tapyrus-setup sign --block_vss=<block_vss[1, i]> --block_vss=<block_vss[2, i]> ... --block_vss=<block_vss[n, i]> --aggregated_public_key=<aggregated_public_key> --nodesecret=<node_secret_share[i]> --private_key=<node_private_key[i]> --block=<block>

output: <local_sig[i]>
```

- `block_vss[j, i]` (j = 1, 2, ..., n) are the block VSSs generated by Step 7.
- `node_private_key[i]` is the private key of Signer[i], generated in Step 2.
- `aggregated_public_key` is an aggregated public key, generated in Step 4.
- `node_secret_share[i]` is the secret key share of Signer[i], generated in Step 4.
- `block` is the genesis block without block proof.
- `local_sig[i]` is the "local signature" described as Î³i in the paper [^4]. signer[i] may reveal `local_sig[i]`.

`local_sig[i]` is encoded hex string of ( r | s ).
   - r - the unsigned big-endian 256-bit encoding of the Schnorr signature's r integer.
   - s - the unsigned big-endian 256-bit encoding of the Schnorr signature's s integer.

Then each signer broadcasts their local_sig.

## Step 9. Compute the signature of the genesis block.

After collecting `local_sig`, we can compute the signature of the genesis block using `tapyrus-setup computesig`

```
tapyrus-setup computesig --sig=<local_sig[1]> --sig=<local_sig[2]> ... --sig=<local_sig[n]> --private_key=<node_private_key[i]> --block=<block> --block_vss=<block_vss[1, i]> --block_vss=<block_vss[2, i]> ... --block_vss=<block_vss[n, i]> --node_vss=<node_vss[1, i]> --node_vss=<node_vss[2, i]> ... --node_vss=<node_vss[n, i]>


output: <block_with_signature>
```

- `local_sig[i]` is the local signatures broadcasted by signers.
- `block` is the genesis block without block proof.
- `node_private_key[i]` is the private key of Signer[i], generated in Step 2.
- `block_vss[j, i]` (j = 1, 2, ..., n) are the block VSSs generated by Step 7.
- `node_vss[j, i]` (j = 1, 2, ..., n) are the node VSSs generated by Step 2.
- `block_with_signature` is the whole genesis block data with block proof as hex string format.

To make block proof, t `local_sig`s are required.
`local_sig`s generated by signers are public values, so signers can reveal them as plaintext without any encryption.

## Step 10. genesis.`networkid`

Create file named 'genesis.`networkid`' and fill it with `block_with_signature`.

## Next Step

Now we are ready to start Tapyrus Core and Tapyrus Signer Network.

To start Tapyrus Core Network, see [Start Tapyrus-core nodes](https://github.com/chaintope/tapyrus-core/blob/master/doc/tapyrus/getting_started.md#5-start-tapyrus-core-nodes).

To start Tapyrus Signer Network, go to [How To configure Tapyrus Signer Network](./configuration.md). The secret values or keys refered in this document will be required to start Tapyrus Signer Network.

- `node_private_key[i]` and `node_public_key[i]` in Step 1
- `aggregated_public_key` and `node_secret_share[i]` in Step 3

In above list, `node_private_key` and `node_secret_share` must be treated as secret.

## Appendix A: Encoding and Encrypting the VSS

In this section, we describe the protocol to encode/encrypt the VSS.
`node_vss[i, j]` in Step 3 and `block_vss[i, j]` in Step 7 have same structure.

Below in this section, notation `vss` means `node_vss[i, j]` or `block_vss[i, j]`.

### Structure of vss

As in Step 2 and Stpe 6 `node_vss` and `block_vss` have 7 fields:

| name                 | size      | explaination                                                                                      |
| -------------------- | --------- | ------------------------------------------------------------------------------------------------- |
| sender_public_key    | 33        | indicates the signer who sends the vss                                                            |
| receiver_public_key  | 33        | indicates the signer to be received the vss                                                       |
| positive commitments | 64 \* len | commitments for secret value for r . an array of the points on the elliptic curve secp256k1.      |
| positive secret      | 32        | secret value for r to perform secret sharing scheme                                               |
| negative commitments | 64 \* len | commitments for secret value for (n - r). an array of the points on the elliptic curve secp256k1. |
| negative secret      | 32        | secret value for (n - r) to perform secret sharing scheme                                         |

Each commitment consists of 32-bits x-coordinate and 32-bits y-coordinate.

### Encryption of `node_vss`

`node_vss` is processed in the rule listed below:

1. Compute p = ECDH(`node_private_key`, `receiver_node_public_key`). where ECDH is a Elliptic-Curve Diffie-Hellman function. p represents a point on the secp256k1 and has 33-byte length.
2. Compute k = h(p). where h is SHA256 hash function. k is used as 32-bytes symmetric key of ChaCha20-Poly1305.
3. Concat all fields except `sender_node_public_key`.
   payload = `receiver_node_public_key` || `positive commitments` || `positive secret` || `negative commitments` || `negative secret`
4. Let n be 64 bits of leading zeros followed by a 32-bit nonce, where:
   nonce = h(`node_public_key[1]` || `node_public_key[2]` || ... || `node_public_key[n]` || `networkid` || `block_height` || `threshold`)
5. Encrypt payload with ChaCha20-Poly1305 encrpytion function.
   enc_payload = chacha20_poly1305_encrypt(k, n, ad = '', payload)
6. Encode `sender_node_public_key` || enc_payload using Base58.

### Encryption of `block_vss`

`block_vss` is processed in the rule listed below.
it is the same as the encryption of `node_vss` except nonce used by chacha20_poly1305_encrypt function.

1. Compute k = ECDH(`block_private_key`, `receiver_block_public_key`).
2. Compute sk = h(k). where h is SHA256 hash function.
3. Concat all fields except `sender_block_public_key`.
   payload = `receiver_block_public_key` || `positive commitments` || `positive secret` || `negative commitments` || `negative secret`
4. Let n be a 96-bit null-nonce (0x000000000000000000000000).
5. Encrypt payload with ChaCha20-Poly1305 encrpytion function.
   enc_payload = chacha20_poly1305_encrypt(k, n, ad = '', payload)
6. Encode `sender_block_public_key` || enc_payload using Base58.

## Appendix B: Example Scenario

// TODO: Write usage of tapyrus-vss.

## Appendix C: Security Consideration

### Nonce used by Encrypting with ChaCha20-Poly1305

As described in Appendix A, we use ChaCha20-Poly1305 encryption to generate vss.
`networkid` is used as nonce in encrypting `node_vss`.
Note that according to security requirement of ChaCha20, so we can not reuse same networkid with same node's keypair.
In generating `block_vss`, fixed null-nonce can be used because keypair is ephemeral.

### Communicating with a protocol with PFS

We suppose that signers can establish secure connection as described in the section [Overview](#Overview)
It is required to use a communication method having the property of PFS in order to minimize leaked information even if the encryption algorithm used in this version is broken in the future.
Otherwise, the private key and the node secret may leak from the past communication contents.
